# Input variables
INPUT_FILE ?=
OUTPUT_DIR ?=
SPECIES_ID ?=
# CHR_ID ?=
REQUIRE_UTRS ?= yes
LAUNCHER ?= python
PRED_BATCH_SIZE ?= 32
PRED_DTYPE ?= bfloat16

# Model configuration
HEAD_MODEL_PATH ?= plantcad/GeneCAD-l8-d768-PC2-Large
BASE_MODEL_PATH ?= kuleshov-group/PlantCAD2-Large-l48-d1536

# Validate required variables
ifndef INPUT_FILE
  $(error INPUT_FILE is required. Set it via: INPUT_FILE=/path/to/input.fasta)
endif
ifndef OUTPUT_DIR
  $(error OUTPUT_DIR is required. Set it via: OUTPUT_DIR=/path/to/output)
endif
ifndef SPECIES_ID
  $(error SPECIES_ID is required. Set it via: SPECIES_ID=species_id)
endif
# ifndef CHR_ID
#   $(error CHR_ID is required. Set it via: CHR_ID=chromosome_id)
# endif

# Pipeline directory structure
PIPELINE_DIR = $(OUTPUT_DIR)/pipeline
CHROMOSOME_LIST = $(PIPELINE_DIR)/chromosomes.txt

# Get chromosome IDs from the chromosome list file
CHROM_IDS := $(shell cat $(CHROMOSOME_LIST) 2>/dev/null || echo "default_chromosome")

# Define all pipeline targets
.PHONY: all clean help sequences predictions annotations extract_chromosomes
all: $(OUTPUT_DIR)/predictions.gff

# Convenient aliases
sequences: $(foreach chr,$(CHROM_IDS),$(PIPELINE_DIR)/sequences_$(chr).zarr)     # Requires CPU-only
predictions: $(foreach chr,$(CHROM_IDS),$(PIPELINE_DIR)/predictions_$(chr).zarr) # Requires CPU + GPU
annotations: $(OUTPUT_DIR)/predictions.gff    # Requires CPU-only

# New target to extract chromosome headers
extract_chromosomes: $(CHROMOSOME_LIST)

# Help target
help:
	@echo "Available targets:"
	@echo "  all - Run complete prediction pipeline"
	@echo "  extract_chromosomes - Extract chromosome headers from FASTA"
	@echo "  sequences - Extract sequences only"
	@echo "  predictions - Generate predictions only"
	@echo "  annotations - Run complete pipeline (alias for all)"
	@echo "  clean - Remove all generated files"
	@echo ""
	@echo "Required variables:"
	@echo "  INPUT_FILE - Path to input FASTA file"
	@echo "  SPECIES_ID - Species identifier"
#	@echo "  CHR_ID - Chromosome identifier"
#	@echo "  HEAD_MODEL_PATH - Path to GeneCAD model checkpoint"
	@echo "  OUTPUT_DIR - Output directory for results"
	@echo ""
	@echo "Optional variables:"
	@echo "  REQUIRE_UTRS - Require UTRs in final output (default: yes)"
	@echo "  HEAD_MODEL_PATH - Path to GeneCAD model checkpoint"
	@echo "  BASE_MODEL_PATH - Path to PlantCAD model checkpoint (default: kuleshov-group/PlantCAD2-Small-l24-d0768)"
	@echo "  LAUNCHER - Command launcher for GPU jobs (default: python)"
	@echo "  PRED_BATCH_SIZE - Batch size for prediction (default: 32)"

# Extract chromosome headers from FASTA file
$(CHROMOSOME_LIST): $(INPUT_FILE)
	@mkdir -p $(PIPELINE_DIR)
	python scripts/extract_chromosome_headers.py \
	  --input $(INPUT_FILE) \
	  --output $(CHROMOSOME_LIST)

# Extract sequences from input FASTA file
# $(PIPELINE_DIR)/sequences.zarr: $(INPUT_FILE)
# 	@mkdir -p $(PIPELINE_DIR)
# 	python scripts/extract.py extract_fasta_file \
# 	  --species-id $(SPECIES_ID) \
# 	  --fasta-file $(INPUT_FILE) \
#	  --chrom-map "$(CHR_ID):$(CHR_ID)" \
#	  --tokenizer-path $(BASE_MODEL_PATH) \
#	  --output $(PIPELINE_DIR)/sequences.zarr

# Pattern rule for extracting sequences for each chromosome
$(PIPELINE_DIR)/sequences_%.zarr: $(INPUT_FILE) | $(CHROMOSOME_LIST)
	@mkdir -p $(PIPELINE_DIR)
	# Get the actual chromosome ID from the target name
	chr_id=$(notdir $(basename $@)); \
	chr_id=$${chr_id#sequences_}; \
	python scripts/extract.py extract_fasta_file \
	  --species-id $(SPECIES_ID) \
	  --fasta-file $(INPUT_FILE) \
	  --chrom-map "$$chr_id:$$chr_id" \
	  --tokenizer-path $(BASE_MODEL_PATH) \
	  --output $@

# Pattern rule for generating predictions for each chromosome
$(PIPELINE_DIR)/predictions_%.zarr: $(PIPELINE_DIR)/sequences_%.zarr
	$(LAUNCHER) scripts/predict.py create_predictions \
	  --input $< \
	  --output-dir $@ \
	  --model-path $(BASE_MODEL_PATH) \
	  --model-checkpoint $(HEAD_MODEL_PATH) \
	  --species-id $(SPECIES_ID) \
	  --chromosome-id $* \
	  --batch-size $(PRED_BATCH_SIZE) \
	  --dtype $(PRED_DTYPE)

# Pattern rule for detecting intervals for each chromosome
$(PIPELINE_DIR)/intervals_%.zarr: $(PIPELINE_DIR)/predictions_%.zarr
	python scripts/predict.py detect_intervals \
	  --input-dir $< \
	  --output $@ \
	  --decoding-methods "direct,viterbi" \
	  --remove-incomplete-features yes

# Pattern rule for exporting raw GFF for each chromosome
$(PIPELINE_DIR)/predictions__raw_%.gff: $(PIPELINE_DIR)/intervals_%.zarr
	python scripts/predict.py export_gff \
	  --input $< \
	  --output $@ \
	  --chromosome-id $* \
	  --decoding-method viterbi \
	  --min-transcript-length 3 \
	  --strip-introns yes

# Pattern rule for filtering by feature length for each chromosome
$(PIPELINE_DIR)/predictions__raw__feat_len_2_%.gff: $(PIPELINE_DIR)/predictions__raw_%.gff
	python scripts/gff.py filter_to_min_feature_length \
	  --input $< \
	  --output $@ \
	  --feature-types "five_prime_UTR,three_prime_UTR,CDS" \
	  --min-length 2

# Pattern rule for filtering by gene length for each chromosome
$(PIPELINE_DIR)/predictions__raw__feat_len_2__gene_len_30_%.gff: $(PIPELINE_DIR)/predictions__raw__feat_len_2_%.gff
	python scripts/gff.py filter_to_min_gene_length \
	  --input $< \
	  --output $@ \
	  --min-length 30

# Pattern rule for filtering to valid genes for each chromosome
$(PIPELINE_DIR)/predictions__raw__feat_len_2__gene_len_30__has_req_feats_%.gff: $(PIPELINE_DIR)/predictions__raw__feat_len_2__gene_len_30_%.gff
	python scripts/gff.py filter_to_valid_genes \
	  --input $< \
	  --output $@ \
	  --require-utrs $(REQUIRE_UTRS)

# Aggregate all chromosome GFF files into final output
$(OUTPUT_DIR)/predictions.gff: $(foreach chr,$(CHROM_IDS),$(PIPELINE_DIR)/predictions__raw__feat_len_2__gene_len_30__has_req_feats_$(chr).gff) | extract_chromosomes
	@mkdir -p $(OUTPUT_DIR)
	@echo "##gff-version 3" > $@
	@for chr in $(CHROM_IDS); do \
		echo "##sequence-region $$chr 1 999999999" >> $@; \
	done
	@for chr in $(CHROM_IDS); do \
		cat $(PIPELINE_DIR)/predictions__raw__feat_len_2__gene_len_30__has_req_feats_$${chr}.gff | \
		grep -v "^#" >> $@; \
	done

# Clean target
clean:
	rm -rf $(OUTPUT_DIR)
